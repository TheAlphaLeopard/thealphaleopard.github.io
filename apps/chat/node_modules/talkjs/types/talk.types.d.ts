/**
 * @public
 * Provides additional parameters to custom message action or conversation action events.
 */
export declare interface ActionEventParams {
    /**
     * Any number of key/value pairs that will be sent with the action event.
     *
     * Add to action buttons in your theme components with the syntax `data-<key>=<value>`,
     * or to action buttons in messages with the syntax
     * `action?<key>=<value>`.
     *
     * Examples:
     *
     * The following action button theme component will emit a `color` action event
     * when you click it, with a parameter called `choice` that takes the value `red`:
     *
     * `<ActionButton action="color" data-choice="red">Red</ActionButton>`
     *
     * The following action button message markup will emit a `color` message action event
     * when you click it, with a parameter called `choice` that takes the value `blue`:
     *
     * `<actionbutton:color?choice=blue|Blue>`
     *
     * Both the key and the value must be strings; arbitrarily deeply nested JSON is not supported.
     */
    [key: string]: string;
}

/**
 * @public
 * @hidden due to being empty
 * @deprecated Use `chatbox.onBlur(() => {...})` instead, without an event parameter.
 */
export declare interface BlurEvent {
}

/**
 * Sent by {@link Session.onBrowserPermissionDenied} when the user tried to do
 * an action that require explicit browser permission, but it was denied.
 *
 * @public
 */
export declare interface BrowserPermissionDeniedEvent {
    /**
     * The type of permission that was denied.
     *
     * @remarks
     * Note that more possible values may be added in the future, so make sure your
     * handler can deal with unknown permission types gracefully.
     */
    type: PermissionType;
}

/**
 * Sent by {@link Session.onBrowserPermissionNeeded} when a browser permission
 * dialog is about to be shown to the user.
 *
 * @public
 */
export declare interface BrowserPermissionNeededEvent {
    /**
     * The type of permission requested.
     *
     * @remarks
     * Note that more possible values may be added in the future, so make sure your
     * handler can deal with unknown permission types gracefully.
     */
    type: PermissionType;
    /**
     * Cancel whatever user action caused the permission to be requested.
     *
     * @remarks
     * For example, if a user wants to share their location for the first time so
     * that this event is triggered, then if you call `preventDefault()`, no
     * permission will be requested from the browser, the location sharing will be
     * cancelled, and TalkJS will continue as if the location sharing button had
     * not been clicked at all.
     *
     * This may be useful if you're using this event to show custom UI elements
     * that nudge users towards granting permission, and this UI has a "cancel"
     * button.
     */
    preventDefault(): void;
}

/**
 * A messaging UI for just a single conversation
 *
 * @remarks
 * There is no way for the user to switch between conversations
 * (but you can change the active conversation through {@link Chatbox.select}).
 * Create a Chatbox through {@link Session.createChatbox} and then call
 * {@link Chatbox.mount} to show it.
 * @public
 */
export declare interface Chatbox extends UIBox {
    /**
     * Renders the Chatbox UI inside a DOM element on your page.
     *
     * @remarks
     * The container element specified by `container` must either be a DOM Element (as returned by e.g.
     * `document.getElementById`) or a JQuery object with a single element.
     */
    mount(container: HTMLElement | null): Promise<void>;
    /**
     * Destroys the chatbox and removes it from the DOM
     *
     * @remarks
     * Destroys the chatbox, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the chatbox container from the DOM.
     */
    destroy(): void;
}

/**
 * @alias UIBox Chatbox
 * @public
 */
export declare interface ChatboxOptions {
    /**
     * Controls the text direction (for supporting right-to-left languages such as Arabic and Hebrew). TalkJS tries
     * to determine the appropriate text direction from the parent page, but if that does not work or you want to
     * explicitly control it, you can override it here. Defaults to "rtl".
     */
    dir?: "rtl" | "ltr";
    /**
     * Sets the message input box to the given text.
     * You can use this to suggest a certain initial message to be sent. The user can still edit it before hitting "send".
     *
     * @deprecated We recommend using {@link MessageField.setText} before mounting the chatbox to precisely control when message suggestions are shown.
     */
    messageSuggestion?: string;
    /**
     * Used to control if the Chat Header is displayed in the UI. Defaults to true.
     */
    showChatHeader?: boolean;
    /**
     * Controls what text appears in the chat title, in the header above the messages.
     * Defaults to `"participants"`.
     *
     * (also see {@link ChatboxOptions.chatSubtitleMode} and {@link InboxOptions.feedConversationTitleMode})
     *
     * @deprecated This field only has effect if you use a {@link https://talkjs.com/docs/Features/Themes/Legacy_Themes_(limited_CSS)/ | Legacy Theme}, or an older custom theme which does not have a ChatHeader component. If you do not, edit the ChatHeader component in the theme editor instead.
     */
    chatTitleMode?: "subject" | "participants";
    /**
     * Controls what text appears in the chat subtitle, right below the chat title.
     * No subtitle is displayed when the conversation has no subject set or when set to `null`.
     * Defaults to `"subject"`.
     *
     * (also see {@link ChatboxOptions.chatTitleMode} and {@link InboxOptions.feedConversationTitleMode})
     *
     * @deprecated This field only has effect if you use a {@link https://talkjs.com/docs/Features/Themes/Legacy_Themes_(limited_CSS)/ | Legacy Theme }, or an older custom theme which does not have a ChatHeader component. If you do not, edit the ChatHeader component in the theme editor instead.
     */
    chatSubtitleMode?: "subject" | "participants" | null;
    /**
     * TalkJS leverages `iframe`s behind the scenes and therefore not all services that you use in your app will work out of the box.
     * This option adds support for a number of services to help you use them. Let us know if you're missing any.
     */
    thirdparties?: ThirdPartyOptions;
    /**
     * Used to control which messages are shown in the message list, depending on a type, origin
     * or custom message attributes.
     *
     * *Note*: Messages are only filtered in the message list. The inbox UI's conversation feed will always show the last message sent to the conversation, regardless of the message filter set.
     *
     * See {@link MessagePredicate} for all available options.
     *
     * You can also modify the filter on the fly using {@link UIBox.setMessageFilter}.
     */
    messageFilter?: MessagePredicate;
    /**
     * TalkJS can translate conversations to the current user's locale using Google Translate.
     * This option specifies which conversations should be translated in this UI. You can pass a boolean to enable or turn off
     * translation for all conversations, "auto" to enable translation on conversations where users have different locales,
     * or you can pass an array of {@link ConversationBuilder}s or conversation Ids to be translated.
     * This feature is only available on the Growth plan and above. Make sure you add your Google Translate API key on the "Settings" page of the dashboard.
     */
    translateConversations?: boolean | "auto" | string[] | ConversationBuilder[];
    /**
     * Set this to `true` to show a translation toggle in all conversations.
     * Set this to `"auto"` to show a translation toggle in conversations where there are participants with different locales.
     * This setting defaults to `false`, meaning that no toggles will be shown.
     * In order to use this, you must be on the Growth plan, and set a Google Translate API key on the "Settings" page of the dashboard.
     */
    showTranslationToggle?: boolean | "auto";
    /**
     * Settings that affect the behavior of the message field
     */
    messageField?: MessageFieldOptions;
    /**
     * Overrides the theme used for this chat UI.
     *
     * @remarks
     * This only works with themes created in the Theme Editor. If you don't pass a theme name, we'll first check for a theme set in the user's role, and then fall back to using the default theme.
     *
     * You can either pass the name of the theme you'd like to use, or a {@link ThemeOptions} object, which you can use to pass variables to your theme.
     */
    theme?: string | ThemeOptions;
    /**
     * Enables capturing {@link Chatbox.onKeyup} events.
     *
     * @remarks
     * Note: Setting this to true also disables any non-standard keyboard shortcuts in TalkJS.
     *
     * At the time of writing, the only such shortcut is that when `captureKeyboardEvents` is
     * disabled, TalkJS will auto-focus the message field if the user starts typing but no input field
     * is focused.
     */
    captureKeyboardEvents?: boolean;
    /**
     * Sets metadata for the current session.
     *
     * - `visible` manually sets the information about the visibility of TalkJS.
     *   This is useful when TalkJS is hidden with CSS. TalkJS will assume that UIs
     *   marked `visible: false` cannot be seen, and thus messages arriving on this UI will
     *   not be marked as read until you set `visible` to true again.
     *
     * - `custom` is an additional parameter to store the custom fields, that you
     *   may want to use in the REST API call.
     */
    presence?: UserPresence;
}

/** @public
 * @hidden due to being empty
 * @deprecated Use `popup.onClose(() => {...})` instead, without an event parameter
 */
declare interface CloseEvent_2 {
}
export { CloseEvent_2 as CloseEvent }

/**
 * Allows you to filter conversations down to a specific subset.
 *
 * @remarks
 * Use with {@link Inbox.setFeedFilter} or pass {@link InboxOptions.feedFilter} to
 * {@link Session.createInbox}.
 *
 * The first element must be the string "any", and the second element a list of SimpleConversationPredicate objects.
 *
 * For example, to match all the conversations to which you have read access,
 * or whose custom "accountId" field has the "my_account" value, use the following:
 * ```js
 * ["any", [{"access": ["==", "Read"]}, {"custom": {"accountId": ["==", "my_account"]}}]]
 * ```
 *
 * See {@link SimpleConversationPredicate} for all available options.
 *
 * @noinline
 * @public
 */
export declare type CompoundConversationPredicate = [
"any",
SimpleConversationPredicate[]
];

/**
 * Lets you show only specific messages in the chat panel of a Chatbox, Inbox or Popup.
 *
 * @remarks
 * Used in methods like {@link Chatbox.setMessageFilter}.
 *
 * The first element must be the string "any", and the second element a list of SimpleMessagePredicate objects.
 *
 * For example, to match all the messages that are either of the type SystemMessage,
 * or whose sender has the "admin" role, use the following:
 * ```js
 * ["any", [{"type": ["==", "SystemMessage"]}, {"sender": {"role": ["==", "admin"]}}]]
 * ```
 *
 * See {@link SimpleMessagePredicate} for all available options.
 *
 * @noinline
 * @public
 */
export declare type CompoundMessagePredicate = ["any", SimpleMessagePredicate[]];

/**
 * Encapsulates an active conversation between two parties.
 *
 * @remarks
 * Use this object to send system messages to the conversation or to programmatically select a
 * conversation by passing it to {@link Inbox.select}.
 *
 * Conversation objects are created with the deprecated {@link Session.getOrStartConversation}
 * method.
 *
 *
 * @public
 * @deprecated Use {@link Session.getOrCreateConversation} instead
 */
export declare interface Conversation {
    /**
     * The ID of the conversation
     */
    readonly id: string;
    /**
     * @hidden
     * An array of {@link Participant | Participants} in the conversation.
     */
    participants: Array<Participant>;
    /**
     * An optional conversation subject which is displayed in the chat header
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    subject?: string | null;
    /**
     * Optional custom conversation meta data
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    welcomeMessages?: Array<string> | null;
    /**
     * An optional URL to a photo which will be shown as the photo for the conversation.

     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    photoUrl?: string | null;
}

/**
 * @public
 * A string that must be `"ReadWrite"`, `"Read"` or `"None"`.
 */
export declare type ConversationAccessLevel = "ReadWrite" | "Read" | "None";

/**
 * @public
 * Emitted from {@link Chatbox.onCustomConversationAction} when a user clicks on a
 * custom action in a conversation within the TalkJS UI
 */
export declare interface ConversationActionEvent {
    action: string;
    params: ActionEventParams;
    /**
     * The value will be `null` if the conversation action is triggered
     * from inside the `ConversationListHeader` component.
     */
    conversation: ConversationData | null;
}

/**
 * Conversation attributes that can be set using {@link ConversationBuilder.setAttributes}
 * @public
 */
export declare interface ConversationAttributes {
    /**
     * A human-readable subject of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://example.com/booking/18644|home by the sea>!`.
     *  URLs and email addresses are made clickable, and emojis made to work cross-platform.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    subject?: string | null;
    /**
     * The URL of a photo to be used for this conversation in the TalkJS UI in case there are more than 2 participants
     * (TalkJS shows the photo of the other participant in a 1-on-1 conversation)
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    photoUrl?: string | null;
    /**
     * Custom metadata that is stored with the conversation
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: {
        [key: string]: string | null;
    } | null;
    /**
     * Messages which are sent at the beginning of a chat.
     * In this case the messages will appear as system messages.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    welcomeMessages?: Array<string> | null;
}

/**
 * A Conversation Builder represents a conversation that is about to be created, fetched, or updated.
 * You can use this object to set up or modify a conversation before showing it.
 *
 * Note: any changes you make here will not be sent to TalkJS immediately.
 * Instead, instantiate a TalkJS UI using methods such as {@link Session.createInbox}.
 *
 * @public
 */
export declare interface ConversationBuilder {
    /**
     * An optional conversation subject which will be displayed in the chat header.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    subject?: string | null;
    /**
     * Allows custom conversation metadata to be stored in the form `{ [name: string]: string }`
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * An optional URL to a photo which will be shown as the photo for the conversation.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    photoUrl?: string | null;
    /**
     * Messages which are sent at the beginning of a chat.
     * In this case the messages will appear as system messages.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    welcomeMessages?: Array<string> | null;
    /**
     * Sets a participant of the conversation.
     *
     * @remarks
     * This method is idempotent and can be called multiple times.
     *
     * @param user - A `User` object that identifies the person who is a participant of the
     * conversation. The user is uniquely identified by their id; all other fields (name, photo etc)
     * are overwritten in the TalkJS database each  time they change.
     * @param settings - An optional setting of participation, can be an initial `access` right or
     * if user should be notified.
     */
    setParticipant(user: User, settings?: Partial<ParticipationSettings>): void;
    /**
     * Used to set certain attributes for a specific conversation
     *
     * @remarks
     * For example:
     *
     * ```
     * conversation.setAttributes({subject: "Booking question"});
     * conversation.setAttributes({custom:
     *   {
     *     sold: "true",
     *     itemId: "720"
     *   }
     * });
     *
     * ```
     *
     */
    setAttributes(attributes: ConversationAttributes): void;
    /**
     * Sends a text message in a given conversation.
     * @param text - The message body that is to be sent.
     */
    sendMessage(text: string, options?: SendMessageOptions): Promise<void>;
    /**
     * Removes the current user from this conversation.
     *
     * @returns A promise that resolves with true upon success (indicating that
     * the user has been removed from this conversation), or false when the user
     * did not have the appropriate permissions, as defined on the "Chat UI" page in the
     * TalkJS dashboard). The promise may reject in case of an unexpected error.
     */
    leave(): Promise<boolean>;
}

/** @public */
export declare interface ConversationData {
    /**
     * The ID of the conversation
     */
    id: string;
    /**
     * Contains custom metadata for the conversation if it was set using {@link ConversationBuilder.custom}.
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     * When sending `custom: null` all properties and values will be removed.
     */
    custom: CustomData;
    /**
     * Contains the conversation subject if it was set using {@link ConversationBuilder.subject}.
     */
    subject: string | null;
    /**
     * Contains the URL of a photo was set using {@link ConversationBuilder.subject}.
     */
    photoUrl: string | null;
    /**
     * One or more welcome messages that will display to the user as a SystemMessage
     */
    welcomeMessages: Array<string> | null;
    /**
     * A map of the access rights for the participants in this conversation.
     *
     * This property is not guaranteed to be complete.
     * It always includes the current user, but does not always list other participants.
     *
     * Specifically, `ConversationData` returned from the following functions will only include the current user: `Session.onMessage`, `Session.onDesktopNotificationClicked`, `Session.unreads.onChange`.
     * In all other cases, this field contains every participant in the conversation.
     *
     * Note on guest access:
     * This field indicates a user's access as a participant.
     * Guests always have "ReadWrite" access and are not included in this map
     */
    participants: Record<string, {
        access: "Read" | "ReadWrite";
    }>;
}

/**
 * Allows you to filter conversations down to a specific subset.
 *
 * @remarks
 * Use with {@link Inbox.setFeedFilter} or pass {@link InboxOptions.feedFilter} to
 * {@link Session.createInbox}.
 *
 * The ConversationPredicate can be either of the following:
 *
 * - a single SimpleConversationPredicate object that filters based on all the fields of the predicate
 *
 * - an array that gives you all the conversations that satisfy at least one of the SimpleConversationPredicates
 *
 * See {@link SimpleConversationPredicate} and {@link CompoundConversationPredicate} for all available options.
 *
 * @noinline
 * @public
 */
export declare type ConversationPredicate = SimpleConversationPredicate | CompoundConversationPredicate;

/** @public
 *
 * This represents the interface of the event triggered from {@link Inbox.onConversationSelected}.
 */
export declare interface ConversationSelectedEvent {
    /**
     * The current TalkJS User
     */
    me: UserData;
    /**
     * @deprecated When you are the only participant in the conversation, this property includes the current user. Use `participants` and filter out the current user instead.
     *
     * The other participants in the conversation that are not the current user
     */
    others?: Array<UserData>;
    /**
     * The participants in the conversation, including the current user
     */
    participants?: Array<UserData>;
    /**
     * The current conversation object
     */
    conversation: ConversationData | null;
}

/**
 * @public
 * Used to store additional metadata on users, conversations and messages
 */
export declare interface CustomData {
    /**
     * Any number of key/value pairs of your choosing to be stored along with the associated resource.
     * You can use custom data for all kinds of purposes, such as customizing a user's email notification text, transmitting contextual user data, or making email login tokens.
     *
     * Both the key and the value must be strings; arbitrarily deeply nested JSON is not supported. Example:
     *
     * ```
     * {"country":"nl", "itemId": "720"}
     * ```
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    [key: string]: string;
}

/**
 * @public
 * A string or a two-element array that forms a predicate about a string field in a `custom` field.
 *
 * @remarks
 * Used in {@link MessagePredicate} and {@link ConversationPredicate}.
 * Allows all forms in {@link FieldPredicate} plus the following:
 *
 * - `"exists"`
 *
 * - `"!exists"`
 */
export declare type CustomFieldPredicate = FieldPredicate<string> | "exists" | "!exists";

/**
 * Sent by {@link Session.onDesktopNotificationClicked} when a user clicks on a browser notification.
 *
 * @public
 */
export declare interface DesktopNotificationClickedEvent {
    conversation: ConversationData;
}

/**
 * @public
 * This event is triggered when {@link https://talkjs.com/docs/Features/Notifications/Browser_Notifications | desktop notifications} are toggled.
 */
export declare interface DesktopNotificationToggledEvent {
    /**
     * Boolean indicating if desktop Notifications are enabled or not
     */
    isEnabled: boolean;
}

/**
 * @public
 * A machine-readable error code enum.
 *
 * @remarks
 * Supports the following values:
 *
 * - `NOTIFICATIONS_PERMISSION_DENIED`
 *
 * - `NOTIFICATIONS_NOT_SUPPORTED`
 *
 * - `ARGUMENT_INVALID`
 */
export declare enum ErrorCode {
    NOTIFICATIONS_PERMISSION_DENIED = 0,
    NOTIFICATIONS_NOT_SUPPORTED = 1,
    ARGUMENT_INVALID = 2
}

/**
 * @public
 * A two-element array that forms a predicate about a field.
 *
 * @remarks
 * Used in {@link MessagePredicate} and {@link ConversationPredicate}.
 * Possible forms:
 *
 * - `["==", "someValue"]`
 *
 * - `["!=", "someValue"]`
 *
 * - `["oneOf", ["someValue", "someOtherValue"]]`
 *
 * - `["!oneOf", ["someValue", "someOtherValue"]]`
 */
export declare type FieldPredicate<T> = ["==" | "!=", T] | ["oneOf" | "!oneOf", T[]];

/**
 * @public
 * @hidden due to being empty
 * @deprecated Use `chatbox.onFocus(() => {...})` instead, without an event parameter.
 */
declare interface FocusEvent_2 {
}
export { FocusEvent_2 as FocusEvent }

/**
 *  @public
 */
export declare interface FullStoryOptions {
    /**
     * Fullstory hostname
     */
    host?: string;
    /**
     * Fullstory organization ID
     */
    org: string;
}

/**
 * @public
 * @hidden
 * @deprecated Use {@link Session.getOrCreateConversation} instead
 */
export declare interface GetOrStartOptionsA {
    /**
     * A human-readable subject
     * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
     * URLs and email addresses are made clickable, and emojis made to work
     * cross-platform.
     */
    subject?: string;
    /**
     * Additional parameter to store the custom fields, that you
     * want to use in the email template. E.g. `custom.specialToken`
     */
    custom?: {
        [name: string]: string;
    };
    /**
     * Photo to be used for this conversation in the TalkJS UI.
     */
    photoUrl?: string;
    welcomeMessages?: string[];
}

/**
 * @public
 * @hidden
 * @deprecated Use {@link Session.getOrCreateConversation} instead
 */
export declare interface GetOrStartOptionsB {
    participants: Array<User>;
    /**
     * A human-readable subject
     * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
     * URLs and email addresses are made clickable, and emojis made to work
     * cross-platform.
     */
    subject?: string;
    /**
     * Additional parameter to store the custom fields, that you
     * want to use in the email template. E.g. `custom.specialToken`
     */
    custom?: {
        [name: string]: string;
    };
    /**
     * Photo to be used for this conversation in the TalkJS UI.
     */
    photoUrl?: string;
}

/**
 * HTML Panel
 * HTML panels should only be created through {@link Inbox.createHtmlPanel}, {@link Chatbox.createHtmlPanel} or {@link Popup.createHtmlPanel}.
 * @public
 */
export declare interface HtmlPanel {
    /**
     * Shows the panel if it's hidden.
     */
    show(): void;
    /**
     * Hides the panel if it's visible.
     */
    hide(): void;
    /**
     * Changes the panel height.
     *
     * @remarks
     * If you don't need to change the height after the panel is created, you can pass it as an option to the `createHtmlPanel`.
     */
    setHeight(height: number): void;
    /**
     * Returns `true` if the panel is visible, `false` if it's hidden or destroyed
     */
    isVisible(): boolean;
    /**
     * Destroys the HTML panel
     */
    destroy(): Promise<void>;
    /**
     * The HTML Panel iframe's {@link window | https://developer.mozilla.org/en-US/docs/Web/API/Window} object
     */
    window: Window;
    /**
     * This promise resolves when the "DOMContentLoaded" event fires on the ifram's window.
     */
    DOMContentLoadedPromise: Promise<void>;
    /**
     * This promise resolves when the "load" event fires on the ifram's window.
     */
    windowLoadedPromise: Promise<void>;
}

/** @public */
export declare interface HtmlPanelOptions {
    /**
     * Required. URL you want to load inside the HTML panel.
     * Url can be absolute ("https://www.example.com/register-form.html") or relative ("register-form.html").
     * We recommend using same origin pages to have better control of the page.
     * Learn more about HTML Panels and same origin pages {@link https://talkjs.com/docs/Customizations/HTML_Panels.html | here}.
     */
    url: string;
    /**
     * Optional, defaults to 100 (px).
     */
    height?: number;
    /**
     * Optional, defaults to true. Set false if you don't want the HTML panel to be shown after
     * `createHtmlPanel` is called. You can change the visibility of the HTML panels by
     * calling `.hide()` or `.show()` on the `HtmlPanel` instance returned by `createHtmlPanel`'s promise.
     */
    show?: boolean;
    /**
     * Either a `Conversation` object
     * (as returned from `getOrCreateConversation`) or the `id` field of
     * a conversation (which you may have stored in your database).
     * If given the HTML panel called will only show up for that conversation.
     */
    conversation?: Conversation | ConversationBuilder | string;
}

/**
 * The main messaging UI. Chats on the left, messages on the right.
 * Create an Inbox through {@link Session.createInbox} and then call {@link Inbox.mount} to show it.
 * @public
 */
export declare interface Inbox extends UIBox {
    /**
     * The conversation currently shown in the UI.
     *
     * @remarks
     * This field is `null` when the UI does not currently show a conversation (eg
     * because `null` was passed to {@link UIBox.select}, it's an Inbox with only
     * conversation list visible, or the selected conversation could not be
     * found).
     *
     * This field will always be equal to
     * {@link ConversationSelectedEvent.conversation | conversation} in the
     * {@link Inbox.onConversationSelected} event.
     *
     * Also note that because the {@link Inbox.onSelectConversation} event is
     * emitted before the new conversation is actually shown, this field will
     * still reflect the previous conversation at that point.
     */
    readonly currentConversation: ConversationData | null;
    /**
     * Controls which conversations are shown in the conversation feed
     *
     * @remarks
     * Lets you filter conversations in the conversation list, depending on access level, custom
     * conversation attributes or message read status.
     *
     * See {@link ConversationPredicate} for all available options.
     *
     * You can also set the filter in {@link Session.createInbox} using
     * {@link InboxOptions.feedFilter}.
     *
     * @param filter - A predicate object that controls which conversations are shown.
     */
    setFeedFilter(filter: ConversationPredicate): void;
    /**
     * Renders the Inbox UI inside a DOM element on your page
     *
     * @remarks
     * The container element specified by `container` must either be a DOM Element (as returned by e.g.
     * `document.getElementById`) or a JQuery object with a single element.
     */
    mount(container: HTMLElement | null): Promise<void>;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onSelectConversation} instead.
     */
    on(eventType: "selectConversation", handler: (event: SelectConversationEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onConversationSelected} instead.
     */
    on(eventType: "conversationSelected", handler: (event: ConversationSelectedEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onDesktopNotificationToggled} instead.
     */
    on(eventType: "desktopNotificationToggled", handler: (event: DesktopNotificationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onFocus} instead.
     */
    on(eventType: "focus", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onBlur} instead.
     */
    on(eventType: "blur", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.translationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onSelectConversation} instead.
     */
    off(eventType: "selectConversation", handler: (event: SelectConversationEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onConversationSelected} instead.
     */
    off(eventType: "conversationSelected", handler: (event: ConversationSelectedEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onDesktopNotificationToggled} instead.
     */
    off(eventType: "desktopNotificationToggled", handler: (event: DesktopNotificationToggledEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Triggers when a user clicks a conversation in the conversation list.
     *
     * @remarks
     * This event is triggered *before* a conversation is selected.
     * You can prevent the conversation from being actually selected by calling `event.preventDefault()`.
     */
    onSelectConversation(handler: (event: SelectConversationEvent) => void): Subscription;
    /**
     * Triggers after a conversation is selected
     *
     * @remarks
     * This event is emitted in 4 situations:
     *
     * 1. When the Inbox loads;
     *
     * 2. When the user clicks on a conversation in the feed;
     *
     * 3. When something in your code calls {@link Inbox.select}
     *
     * 4. When the Inbox is shown in mobile view, and the user clicks the `< Inbox` button.
     *
     * Note that the event's `conversation` field will be `null` when the inbox loads (and the user
     * has no conversations), when calling {@link Inbox.select} with `null` to deselect any
     * conversation, and in case 4 above.
     */
    onConversationSelected(handler: (event: ConversationSelectedEvent) => void): Subscription;
    /**
     * Triggers when the user toggles the "Desktop Notifications" toggle in the inbox conversation list header.
     */
    onDesktopNotificationToggled(handler: (event: DesktopNotificationToggledEvent) => void): Subscription;
    /**
     * Destroys the inbox and removes it from the DOM
     *
     * @remarks
     * Destroys the inbox, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the inbox container from the DOM.
     */
    destroy(): void;
}

/**
 * @alias UIBox Inbox
 * @public
 */
export declare interface InboxOptions extends ChatboxOptions {
    /**
     * Makes the inbox start up with the given Conversation. Can be passed a value of the type ConversationBuilder (returned by getOrCreateConversation) or the string value of the conversation id. Conversation can be deselected on startup by passing a null value. Passing undefined means that the last conversation (or "no chats yet page") will be displayed.
     *
     * @deprecated Please use {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Inbox/#Inbox__select | Inbox.select} instead.
     */
    selected?: Conversation | ConversationBuilder | string | null;
    /**
     * Controls if the feed header containing the toggle to enable desktop notifications is shown.
     * Defaults to true.
     */
    showFeedHeader?: boolean;
    /**
     * Controls how a chat is displayed in the feed of chats.
     *
     * Note: when set to `"subject"` but a conversation has no subject set, then
     * TalkJS falls back to `"participants"`.
     *
     * When not set, defaults to `"auto"`, which means that in group conversations
     * that have a subject set, the subject is displayed and otherwise the participants.
     *
     * (also see {@link ChatboxOptions.chatSubtitleMode} and {@link ChatboxOptions.chatTitleMode})
     *
     * @deprecated This field only has effect if you use a {@link https://talkjs.com/docs/Features/Themes/Legacy_Themes_(limited_CSS)/ | Legacy Theme }, or an older custom theme which does not have a ConversationListItem component. If you do not, edit the ChatHeader component in the theme editor instead.
     */
    feedConversationTitleMode?: "participants" | "subject" | "auto";
    /**
     * Controls whether the user navigating between conversation should count
     * as steps in the browser history. Defaults to true, which means that if the user
     * clicks the browser's back button, they go back to the previous conversation
     * (if any).
     */
    useBrowserHistory?: boolean;
    /**
     * Used to control which conversations are shown in the conversation feed, depending on access
     * level, custom conversation attributes or message read status.
     *
     * The feedFilter can be either of the following:
     * - a single ConversationPredicate object that filters based on all the fields
     * of the predicate
     * - an array that gives you all the conversations that satisfy at least one
     * of the ConversationPredicates
     *
     * When filtering conversations with an array, the first element must be the string
     * "any", and the second element a list of ConversationPredicate objects.
     *
     * For example, to match all the conversations to which you have read access,
     * or whose custom "accountId" field has the "my_account" value, use the following:
     * ```js
     * ["any", [{"access": ["==", "Read"]}, {"custom": {"accountId": ["==", "my_account"]}}]]
     * ```
     *
     * See {@link ConversationPredicate} for all available options.
     *
     * You can also modify the filter on the fly using {@link Inbox.setFeedFilter}.
     */
    feedFilter?: ConversationPredicate;
    /**
     * Whether to show a "Back" button at the top of the chat screen on mobile devices.
     */
    showMobileBackButton?: boolean;
}

/**
 * @public
 * @hidden
 * Anything that can be JSON-serialised.
 */
export declare type JsonSerializable = string | number | boolean | null | JsonSerializableObject | JsonSerializableArray;

/**
 * @public
 * @hidden
 */
export declare interface JsonSerializableArray extends Array<JsonSerializable> {
}

/**
 * @public
 * @hidden
 */
export declare interface JsonSerializableObject {
    [key: string]: JsonSerializable;
}

/**
 * @public
 * Emitted through {@link Chatbox.onKeyup} when the user presses a key.
 * All fields except `isInputFocused` precisely match the corresponding fields in the browser's
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
 */
declare interface KeyEvent {
    /**
     * True if the event was triggered while an element was focused that can handle keyboard events.
     */
    isInputFocused: boolean;
    altKey: boolean;
    code: string;
    ctrlKey: boolean;
    key: string;
    location: number;
    metaKey: boolean;
    shiftKey: boolean;
    repeat: boolean;
}
export { KeyEvent }
export { KeyEvent as KeyupEvent }

/**
 * @public
 * Triggered when the user clicks a "Leave conversation" action in the chat UI.
 *
 * @see {@link Chatbox.onLeaveConversation}
 */
export declare interface LeaveConversationEvent {
    /**
     * The conversation that the user intends to leave
     */
    conversation: ConversationData;
    /**
     * Call this to prevent the conversation from being left, ie to cancel the
     * user action.
     *
     * @remarks
     * Doing this will turn the "Leave conversation" action into a no-op, so you
     * might want to display some sort of error message to the user so they
     * understand why their click didn't do anything.
     *
     * You can only call `preventDefault` from inside the `onLeaveConversation`
     * event handler or a function immediately invoked from it. Calling
     * `preventDefault` later, or after some promise resolved, has no effect.
     */
    preventDefault(): void;
}

/**
 * @public
 * Triggered when the user clicks a "Mark as unread" action in the chat UI.
 *
 * @see {@link Chatbox.onMarkConversationAsUnread}
 */
export declare interface MarkConversationAsUnreadEvent {
    /**
     * The conversation that the user intends to mark as unread
     */
    conversation: ConversationData;
    /**
     * Call this to prevent the conversation from being marked as unread, ie to
     * cancel the user action.
     *
     * @remarks
     * Doing this will turn the "Mark as unread" action into a no-op, so you might
     * want to display some sort of error message to the user so they understand
     * why their click didn't do anything.
     *
     * You can only call `preventDefault` from inside the
     * `onMarkConversationAsUnread` event handler or a function immediately
     * invoked from it. Calling `preventDefault` later, or after some promise
     * resolved, has no effect.
     */
    preventDefault(): void;
}

/**
 * @public
 * A TalkJS message, used as part of {@link Session.onMessage}
 */
export declare interface Message {
    /**
     * The message's ID.
     */
    id: string;
    /**
     * Contains the {@link ConversationData} that the message belongs to.
     */
    conversation: ConversationData;
    /**
     * 'true' if the message was sent by the current user.
     */
    isByMe: boolean;
    /**
     * The senderID (userID) for the person that sent the message
     */
    senderId: string | null;
    /**
     * The {@link User} that sent the message
     */
    sender: UserData | null;
    /**
     * Contains the message's content
     */
    body: string;
    /**
     * Specifies if if the message is media (file), text or a shared location
     */
    type: "media" | "text" | "location";
    /**
     * UNIX timestamp specifying when the message was sent (UTC, in milliseconds)
     */
    timestamp: number;
    /**
     * 'true' if the message has been read, 'false' has not been seen yet
     */
    read: boolean;
    /**
     * Determines how this message was sent: respectively, Via a web browser (or mobile Webview), via the REST API, via reply-to-email, or using the import API.
     */
    origin: string;
    /**
     * Custom metadata that is stored with the conversation
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom: CustomData;
    /**
     * Only given if the message's `type` equals `"media"`. An object with the URL and filesize (in bytes) of the given file. Attachment dimensions (in px) are sometimes available for image and video attachments, used to set the size of the thumbnail before loading, to prevent content shift when loading media on slower connections.
     */
    attachment: {
        url: string;
        size: number;
        dimensions?: {
            width: number;
            height: number;
        };
    } | null;
    /**
     * Only given if the message's `type` equals `"location"`. An array of two numbers which represent the longitude and latitude of this location, respectively. Only given if this message is a shared location.
     *
     * Example:
     *
     * ```js
     * [51.481083, -3.178306]
     * ```
     */
    location: [number, number] | null;
}

/**
 * @public
 * Emitted from {@link Chatbox.onCustomMessageAction} when a user clicks on a
 * custom action, as defined on the "Chat UI" page of the dashboard.
 */
export declare interface MessageActionEvent {
    action: string;
    params: ActionEventParams;
    message: Message;
}

/**
 * Encapsulates the message entry field tied to the currently selected conversation.
 * @public
 */
export declare interface MessageField {
    /**
     * Focuses the message entry field.
     *
     * @remarks
     * Note that on mobile devices, this will cause the on-screen keyboard to pop up, obscuring part
     * of the screen.
     *
     * This method will silently fail if the participant only has "Read" access in the
     * current conversation.
     */
    focus(): void;
    /**
     * Sets the message field to `text`.
     *
     * @remarks
     * Useful if you want to guide your user with message suggestions. If you want to start a UI
     * with a given text showing immediately, call this method before calling {@link Inbox.mount}
     *
     * This method will silently fail if the participant only has "Read" access in the
     * current conversation.
     *
     * @param text - The text to be displayed in the message entry field
     */
    setText(text: string): void;
    /**
     * Types the given `text` into the message field.
     *
     * @remarks
     * Inserts `text` wherever the cursor currently is.
     *
     * This method may be useful for various bot/simulation scenarios. Additionally, it lets you make
     * it so that any regular keypress lets the user start typing into the message field, even if it
     * is not focused.
     *
     * This method will silently fail if the participant only has "Read" access in the
     * current conversation.
     *
     * To do that, capture the keypress using a regular window event listener, ensure that the user
     * isn't typing into a different input, and then call this method to type the key, followed by
     * {@link MessageField.focus}. Note that TalkJS already does this out-of-the box when the chat UI
     * iframe has focus and {@link ChatboxOptions.captureKeyboardEvents} is off.
     *
     * @param text - The text to be inserted in the message entry field
     */
    typeText(text: string): void;
    /**
     * Gets the current content of the message field.
     */
    getText(): Promise<string>;
    /**
     * Sets the visibility of the Message Field to a given value or to a certain predicate.
     *
     * @remarks
     * See {@link MessageFieldOptions.visible} for examples.
     *
     * @param visible - boolean or a more advanced predicate.
     */
    setVisible(visible: boolean | ConversationPredicate): void;
}

/**
 * @public
 */
export declare interface MessageFieldOptions {
    /**
     * If set to `true`, pressing the enter key sends the message (if there is text in the message
     * field). When set to `false`, the only way to send a message is by clicking or touching the
     * "Send" button. Defaults to `true`.
     */
    enterSendsMessage?: boolean;
    /**
     * Specifies whether the
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#attr-spellcheck | spellcheck}
     * attribute is set on the message field. Note that setting this to `true` may also enable
     * autocorrect on some mobile devices. Defaults to `false`.
     */
    spellcheck?: boolean;
    /**
     * Overrides the "placeholder" in the message field, which displays a dimmed text when no text has yet been entered.
     *
     * Defaults to "Say something..." (or a {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | translation thereof}).
     */
    placeholder?: string;
    /**
     * Determines whether the message field is visible. Pass either a boolean (`false` to hide it),
     * or a {@link ConversationPredicate}. The latter approach lets you show/hide the message field
     * based on properties of the current conversation.
     *
     * For example, to hide the message field when the current user has no write access to the
     * current conversation, do the following:
     *
     * ```js
     * // this predicate holds iff the current user's `access` to the current conversation is
     * // set to "ReadWrite"`:
     * const showMessageField = { access: ["==", "ReadWrite"] };
     * session.createInbox(conversation, { messageField: { visible: showMessageField } });
     * ```
     *
     * Defaults to `true`.
     */
    visible?: boolean | ConversationPredicate;
    /**
     * Determines whether the message field should automatically focus when the user navigates.
     *
     * Defaults to "smart", which means that the message field gets focused whenever a conversation
     * is selected, if possible without negative side effects. I.e. only when:
     *
     * - The message field is inside the browser viewport (so focusing will not unexpectedly cause
     *   the page to scroll)
     *
     * - The user is likely on a desktop/laptop computer (so focusing will not unexpectedly expand a
     *   mobile on-screen keyboard).
     *
     * Note: If you need more control, consider setting `autofocus` to false and calling
     * {@link MessageField.focus} at appropriate times.
     */
    autofocus?: false | "smart";
}

/**
 * Lets you show only specific messages in the chat panel of a Chatbox, Inbox or Popup.
 *
 * @remarks
 * Used in methods like {@link Chatbox.setMessageFilter}.
 *
 * The MessagePredicate can be either of the following:
 *
 * - a single SimpleMessagePredicate object that filters based on all the fields of the predicate
 *
 * - an array that gives you all the messages that satisfy at least one of the SimpleMessagePredicates
 *
 * See {@link SimpleMessagePredicate} and {@link CompoundMessagePredicate} for all available options.
 *
 * @noinline
 * @public
 */
export declare type MessagePredicate = SimpleMessagePredicate | CompoundMessagePredicate;

/**
 * @public
 * A two-element array that forms a predicate about a numeric field.
 *
 * @remarks
 * Used in {@link ConversationPredicate}.
 * Possible forms:
 *
 * - `[">", someNumber]`
 *
 * - `["<", someNumber]`
 *
 * - `[">=", someNumber]`
 *
 * - `["<=", someNumber]`
 *
 * - `["between", [lowerBound, upperBound]]`
 *
 * - `["!between", [lowerBound, upperBound]]`
 */
export declare type NumberPredicate = [">" | "<" | ">=" | "<=", number] | ["between" | "!between", [number, number]];

/**
 * A helper method to predictably compute a Conversation ID based on participants' ids in the given conversation.
 * Use this method if you want to simply create a conversation between two users,
 * not related to a particular product, order or transaction.
 *
 * The order of the parameters does not matter.
 * For example, `Talk.oneOnOneId("a", "b")` yields the same result as `Talk.oneOnOneId("b", "a")`.
 *
 * This method takes the following steps:
 * 1. Take two ids of users and put them in an array
 * 2. Sort them lexicographically
 * 3. JSON encode them
 * 4. hash the result using SHA1, return the first 20 characters
 *
 * In pseudocode, this is what this function does:
 *
 *     var sorted = [me.id, other.id].sort()
 *     var encoded = JSON.encode(sorted)
 *     var hash = sha1(encoded)             // as lowercase hex
 *     return truncate(hash, 20)
 *
 * For a PHP implementation, see https://gist.github.com/eteeselink/4dc3ad32cc478986ff2b5b6361a1825f.
 * {@link https://talkjs.com/?chat | Get in touch} if you need our help implementing this in your backend language.
 * @public
 */
export declare function oneOnOneId(me: User | string, other: User | string): string;

/**
 * @public
 * @hidden due to being empty
 * @deprecated Use `popup.onOpen(() => {...})` instead, without an event parameter
 */
export declare interface OpenEvent {
}

/**
 * @public
 * @hidden
 * Contains information about an individual participant
 */
export declare interface Participant {
    /**
     * A Talk JS {@link User}
     */
    readonly user: User;
    /**
     * Contains access and notification settings for a given user's participation to a given conversation. Used in ConversationBuilder.setParticipant.
     */
    readonly participationSettings: Partial<ParticipationSettings>;
}

/**
 * Specifies access and notification settings for a given user's participation
 * to a given conversation. Used in {@link ConversationBuilder.setParticipant}.
 * @public
 */
export declare interface ParticipationSettings {
    /**
     * Specifies the participant's access permission for a conversation. See {@link ConversationBuilder.setParticipant}
     * @remarks
     * When omitted or `undefined`, the existing value remains unchanged.
     */
    access?: "Read" | "ReadWrite";
    /**
     * Specifies the participants's notification settings. See {@link ConversationBuilder.setParticipant}
     * @remarks
     * When omitted or `undefined`, the existing value remains unchanged.
     */
    notify?: boolean | "MentionsOnly";
}

/**
 * @public
 *
 * A string that is one of `"notifications" | "microphone" | "geolocation"`.
 *
 * @remarks
 * Used in {@link BrowserPermissionNeededEvent} and {@link BrowserPermissionDeniedEvent}
 *
 * Note that more possible values may be added in the future, so make sure your
 * handler can deal with unknown permission types gracefully.
 */
export declare type PermissionType = "notifications" | "microphone" | "geolocation";

/**
 * A messaging UI for just a single conversation.
 *
 * There is no way for the user to switch between conversations
 * (but you can change the active conversation through {@link Popup.select}).
 * Create a Popup through {@link Session.createPopup} and then call
 * {@link Popup.mount} to show it.
 * @public
 */
export declare interface Popup extends UIBox {
    /**
     * Renders the Popup UI on your page
     *
     * @remarks
     * Loads the popup in the background, but by default shows only the launcher button. Pass
     * `{ show: true }` to open the popup as soon as it's loaded.
     */
    mount(options?: {
        show?: boolean;
    }): Promise<void>;
    /**
     * Destroys the popup and removes it from the DOM
     *
     * @remarks
     * Destroys the popup, removes it from the DOM and removes all event listeners it has running.
     */
    destroy(): void;
    /**
     * Shows the Popup
     *
     * @remarks
     * Use this to show a popup that was previously hidden or mounted with a parameter `show: false`.
     * Note: does nothing on unmounted popups. Make sure you call {@link Popup.mount} once before you call `show()` or {@link Popup.hide}.
     */
    show(): void;
    /**
     * Closes the popup, but doesn't remove it from the DOM
     */
    hide(): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onOpen} instead.
     */
    on(eventType: "open", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onClose} instead.
     */
    on(eventType: "close", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onFocus} instead.
     */
    on(eventType: "focus", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onBlur} instead.
     */
    on(eventType: "blur", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onTranslationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("open")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onOpen} instead.
     */
    off(eventType: "open", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("close")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onClose} instead.
     */
    off(eventType: "close", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("keyup")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Triggers when the popup is opened by the user
     *
     * @remarks
     * Only gets triggered when the user performs an action to open the popup.
     * This event is not triggered when you call {@link Popup.show} or when you
     * {@link Popup.mount} it with the `{show: true}` option.
     */
    onOpen(handler: () => void): Subscription;
    /**
     * Triggers when the popup is closed by the user
     *
     * @remarks
     * Only gets triggered when the user performs an action to close the popup,
     * eg when they click the "X" on the launcher or,
     * {@link PopupOptions.showCloseInHeader | if enabled}, in the popup header.
     * This event is not triggered when you call {@link Popup.hide} or
     * {@link Popup.destroy}.
     */
    onClose(handler: () => void): Subscription;
}

/**
 * @alias UIBox Popup
 * @public
 */
export declare interface PopupOptions extends ChatboxOptions {
    /**
     * If enabled, the Popup will reopen every time
     * the user navigates to another page. This way, a conversation can continue
     * while the user browses around. Set to `false` to disable this behavior.
     *
     * Defaults to false.
     */
    keepOpen?: boolean;
    /**
     * Specifies whether to show a round
     * launcher and/or close button beneath the popup in the right bottom corner
     * of the page.
     *
     * @remarks
     * `"close-only"`: show a close button beneath the popup, but don't show a launch button
     *
     * `"always"`: show a launch button when the popup is closed, show a close button when it is visible
     *
     * `"never"`: never show a launcher
     *
     * Note: if you choose `"never"` you may want to override the positioning of the popup as well.
     * Just tune the `__talkjs_popup` class in your CSS.
     *
     * Ignored on mobile, where the popup fills the entire screen so the value is effectively `"never"`.
     *
     * Defaults to `"always"`.
     *
     */
    launcher?: "close-only" | "always" | "never";
    /**
     * Whether to show the "x" icon in the popup header to close the popup.
     * "auto", which is the default value means `true` on mobile and to `false` on desktop.
     */
    showCloseInHeader?: boolean | "auto";
}

/** @public */
export declare const ready: Promise<void>;

/**
 * @public
 * Event data triggered from {@link Inbox.onSelectConversation}.
 */
export declare interface SelectConversationEvent {
    /**
     * The current TalkJS User
     */
    me: UserData;
    /**
     * @deprecated When you are the only participant in the conversation, this property includes the current user. Use `participants` and filter out the current user instead.
     *
     * The other participants in the conversation that are not the current user
     */
    others: Array<UserData>;
    /**
     * The participants in the conversation, including the current user
     */
    participants: Array<UserData>;
    /**
     * The current conversation object
     */
    conversation: ConversationData;
    /**
     * The id of the message to scroll to (This property only exists when a message search result has been selected)
     */
    messageId?: string;
    /**
     * Prevents the clicked conversation from being selected.
     */
    preventDefault(): void;
}

/**
 * @public
 * Selection parameters.
 */
export declare interface SelectConversationOptions {
    /**
     * can be used to select the conversation as a guest, with limited functions
     */
    asGuest?: boolean;
    /**
     * can be used to scroll to a specific message
     */
    messageId?: string;
}

/**
 * @public
 */
export declare interface SenderPredicate {
    /**
     * Only show messages from a sender(s) with a given id.
     *
     * For example:
     *
     * ```js
     * // Don't show messages sent by user with ID 1
     * {sender: {id: ["!=", "1"]}}
     * ```
     */
    id?: FieldPredicate<string>;
    /**
     * Only show messages from senders with a given locale.
     *
     * For example:
     *
     * ```js
     * // Only show messages from senders with locale: en-GB or en-US
     * {sender: {locale: ["oneOf", ["en-GB", "en-US"]}}
     * ```
     */
    locale?: FieldPredicate<string>;
    /**
     * Only show messages from senders who have a particular role.
     *
     * For example:
     *
     * ```js
     * // Only show messages from senders with role: Admin and locale: en-GB
     * {sender: {role: ["==", "Admin"], locale: ["==", "en-GB"]}}
     * ```
     */
    role?: FieldPredicate<string>;
    /**
     * Only show messages from senders who have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in a user's custom data that you have set. It is not necessary for all
     * senders to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Example, assume you have some users with the `alternateRole` field in their custom data:
     *
     * ```js
     * // Only show messages from senders that have the field alternateRole set:
     * {custom: {alternateRole: "!exists" }}
     *
     * // Only show messages from senders that have the field alternateRole set to "support":
     * {custom: {alternateRole: ["==", "support"]}}
     * ```
     *
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
}

/**
 * @public
 * The event triggered when listening for the sendMessage event on the {@link Inbox}, {@link Chatbox} and {@link Popup}.
 * This event is triggered before the message is sent to TalkJS, allowing you to modify the contents of the message or its metadata by
 * using `override()`.
 */
export declare interface SendMessageEvent {
    /**
     * The message that was sent
     */
    message: SentMessage;
    /**
     * The current TalkJS user
     */
    me: UserData;
    /**
     * The current conversation object
     */
    conversation: ConversationData;
    /**
     * This function allows you to modify the contents of the message or its metadata before the message is sent
     */
    override: ({ text, custom }: {
        text?: string;
        custom?: CustomData;
    }) => void;
}

/**
 * @public
 */
export declare interface SendMessageOptions {
    /**
     * An object with any custom data that you may wish to associate with this message. The custom data is sent back to you via webhooks and the REST API.
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: CustomData;
}

/**
 * @public
 * A message that was sent to TalkJS
 */
export declare interface SentMessage {
    /**
     * The message ID of the message that was sent
     */
    id: string | undefined;
    /**
     * The ID of the conversation that the message belongs to
     */
    conversationId: string;
    /**
     * Identifies the message as either a {@link https://talkjs.com/docs/Reference/Concepts/Messages.html | User message} or
     * {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | System message}
     */
    type: "UserMessage" | "SystemMessage";
    /**
     * Contains an Array of {@link User.id}'s that have read the message
     */
    readBy: string[];
    /**
     * Contains the user ID for the person that sent the message
     */
    senderId: string;
    /**
     * Contains the message's text
     */
    text?: string;
    /**
     * Only given if the message contains a file. An object with the URL and filesize (in bytes) of the given file. Attachment dimensions (in px) are sometimes available for image and video attachments, used to set the size of the thumbnail before loading, to prevent content shift when loading media on slower connections.
     */
    attachment?: {
        url: string;
        size: number;
        dimensions?: {
            width: number;
            height: number;
        };
    };
    /**
     * Only given if the message contains a location. An array of two numbers which represent the longitude and latitude of this location, respectively. Only given if this message is a shared location.
     *
     * Example:
     *
     * ```js
     * [51.481083, -3.178306]
     * ```
     */
    location?: [number, number];
}

/**
 * A session represents a user's active browser tab. It also authenticates your app
 * with TalkJS.
 *
 * @public
 */
export declare class Session {
    private readonly _onEventSubscription;
    private readonly _eventEmitter;
    private _uiBoxes;
    /**
     * Whether the session is active and in a valid state.
     *
     * @remarks
     * When false, calling methods on this Session instance will throw errors.
     *
     * This field is false when {@link Session.destroy} has been called in the
     * past. Once a session has been destroyed, you cannot revive it. Instead,
     * create a new session.
     */
    isAlive: boolean;
    /**
     * Holds information about unread conversations. Lets your app be notified
     * when the active user receives a new message.
     */
    readonly unreads: Unreads;
    /** The TalkJS {@link User} associated with the current user in your application. */
    readonly me: User;
    /**
     * A reference to the current user
     * @public
     */
    readonly currentUser: UserRef;
    /**
     * Get a reference to a user, for use with the Realtime API
     *
     * @param id - The ID of the user that you want to reference
     * @returns A UserRef for the user with that ID
     * @public
     */
    user(id: string): UserRef;
    /** Your TalkJS `AppId` that can be found on the "Settings" page of your TalkJS {@link https://talkjs.com/dashboard | dashboard}. */
    readonly appId: string;
    private readonly _sessionId;
    /**
     * Creates a TalkJS Session.
     * @public
     */
    constructor(options: SessionOptions);
    /**
     * Verifies whether the `appId` is valid.
     *
     * @remarks
     * Returns a Promise of a boolean, never rejects.
     */
    hasValidCredentials(): Promise<boolean>;
    private _maybeRestorePopup;
    private _trackWindowFocus;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.getOrCreateConversation}.
     *
     * @param other - A `User` object that identifies the person to converse with.
     * The user is uniquely identified by their id; all other fields (name, photo
     * etc) are overwritten in the TalkJS database each  time they change.
     * @param options - Options used for getOrStartConversation
     *
     * @returns a `Conversation` object that encapsulates a conversation
     * between `me` (given in the constructor) and `other`.
     */
    getOrStartConversation(other: User, options?: GetOrStartOptionsA): Conversation;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.getOrCreateConversation}.
     *
     * @param conversationId - A unique identifier for this conversation. Any user with access to
     *                         this ID can join this conversation.
     *
     * @param options - Options used for getOrStartConversation
     *
     * @returns a `Conversation` object that encapsulates a conversation between `me` (given in the
     * constructor) and zero or more other `participants`.
     *
     */
    getOrStartConversation(conversationId: string, options?: GetOrStartOptionsB): Conversation;
    private _maybeAddMyParticipant;
    /**
     * A method used to either fetch or create a conversation.
     *
     * @remarks
     * Returns a `ConversationBuilder` object that encapsulates a conversation
     * between `me` (given in the constructor) and zero or more other `participants`.
     * Use {@link ConversationBuilder.setParticipant} and {@link ConversationBuilder.setAttributes}
     * on the returned object to further set up your conversation.
     *
     * @param conversationId - A unique identifier for this conversation, such as a channel name or topic ID.
     * Any user with access to this ID can join this conversation. {@link https://talkjs.com/docs/Reference/Concepts/Conversations.html | Read about how to choose a good conversation ID for your use case}.
     * If you want to make a simple one-on-one conversation, consider using {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/The_Talk_Object/#Talk.oneOnOneId | oneOnOneId} to generate one.
     */
    getOrCreateConversation(conversationId: string): ConversationBuilder;
    /**
     * Creates an Inbox UI
     *
     * @remarks
     * The Inbox is TalkJS's most versatile component. It combines a
     * {@link Chatbox} with a panel showing a a list of conversations where the
     * user is a participant. In order to select a conversation inside an Inbox
     * you need to call {@link Inbox.select}.
     *
     * Example:
     * ```js
     * const inbox = session.createInbox();
     * inbox.select(conversation);
     * ```
     *
     * You typically want to call {@link Inbox.mount} after creating the Inbox to
     * make it visible on your app.
     *
     * Call `createInbox` on the messaging page of your app.
     *
     * @param options - Optional. Use these to finetune the behavior of the Inbox.
     */
    createInbox(options?: InboxOptions): Inbox;
    /**
     * Creates a Chatbox UI.
     *
     * @remarks
     * The Chatbox is a slimmer version of the Inbox. It shows a single conversation,
     * without means to switch between conversations. In order to select a conversation inside a Chatbox
     * you need to call {@link Chatbox.select}.
     *
     * Example:
     * ```js
     * const chatbox = session.createChatbox();
     * chatbox.select(conversation);
     * ```
     *
     * You typically want to call {@link Chatbox.mount} after creating the Chatbox to make it visible on your app.
     *
     *
     * Call `createChatbox` on any page you want to show a chatbox of a single conversation.
     *
     * Note: A deprecated two-parameter form of this method, `createChatbox(selectedConversation, options)`, also exists. This form will keep being supported but we recommend not using it new codebases. Instead, call {@link Chatbox.select} immediately after `mount`.
     *
     * @param options - Optional, Use these to finetune the behavior of the Chatbox.
     */
    createChatbox(options?: ChatboxOptions): Chatbox;
    /**
     * @public
     * @deprecated Instead, do `const chatbox = session.createChatbox(options); chatbox.select(conversation);`.
     * @hidden
     */
    createChatbox(conversation: Conversation | ConversationBuilder | null | undefined, options?: ChatboxOptions): Chatbox;
    /**
     * @public
     * @deprecated Instead, do `const popup = session.createPopup(options); popup.select(conversation);`.
     * @hidden
     */
    createPopup(conversation: Conversation | ConversationBuilder | null | undefined, options?: PopupOptions): Popup;
    /**
     * Creates a Popup UI.
     *
     * @remarks
     * The Popup is a positioned box containing a conversation. It shows a single conversation,
     * without means to switch between conversations.
     * In order to select a conversation inside a Popup
     * you need to call the {@link Popup.select}.
     *
     * Example:
     * ```js
     * const popup = session.createPopup();
     * popup.select(conversation);
     * ```
     *
     * You typically want to call {@link Popup.mount} after creating the popup to make it visible on your app.
     *
     *
     * Call `createPopup` on any page you want to show a popup of a single conversation.
     *
     * Note: A deprecated two-parameter form of this method, `createChatbox(selectedConversation, options)`, also exists. This form will keep being supported but we recommend not using it new codebases. Instead, call {@link Chatbox.select} immediately after `mount`.
     * In order to have a popup on each site you need to call
     * `createPopup` on any page you want to show a popup with the conversation.
     *
     * @param options - Optional, Use these to finetune the behavior of the Popup.
     */
    createPopup(options?: PopupOptions): Popup;
    /**
     * Used to configure TalkJS to use a legacy theme hosted on the same location
     * as your application for development.
     *
     * @remarks
     * Tells TalkJS to use a theme hosted on the same location as your application
     * (e.g. localhost:8000/). e.g. Call
     * `talkSession.syncThemeForLocalDev("/assets/css/talkjs-theme.css")` just
     * before you call `createInbox` or `createChatbox`. TalkJS will then use the
     * specified file instead of using a theme created in the dashboard.
     *
     * @param path - The path to the legacy theme's CSS file
     *
     * @deprecated We recommend switching to
     * {@link https://talkjs.com/docs/Features/Themes/The_Theme_Editor/ | Custom Themes},
     * which are substantially more powerful and do not have a practical need for
     * a method like this.
     */
    syncThemeForLocalDev(path: string): void;
    /**
     * Sets desktop notification on or off.
     *
     * @remarks
     * Has the same effect as toggling the "Desktop notification" toggle in the
     * TalkJS Inbox UI. Use this function to replicate that toggle elsewhere in
     * your UI if you're using TalkJS in a mode that doesn't show this toggle.
     *
     * When desktop notifications are enabled for the first time, the browser will
     * show a prompt to ask the user for permission. The call will only succeed if
     * the user accepts it.
     *
     * We recommend only calling this function in response to user action, so
     * users know that they can expect a permission prompt. This significantly
     * increases the percentage of users that click "Allow".
     *
     * Notably, we strongly recommend that you do not call this function
     * immediately when the page loads, because many browsers auto block
     * notifications when permission is requested on page load. This is likely a
     * measure to prevent overly aggressive news sites from being able to spam
     * past visitors.
     *
     * @param isEnabled - Whether notifications should be enabled.
     * @param alertOnFailure - Whether to show an alert message when enabling
     * notifications fails. Defaults to `true`, unless you add a handler for
     * {@link Session.onBrowserPermissionDenied}, which emits an event when the
     * permission request fails. If there's a handler for that event, then this
     * defaults to false.
     *
     * @returns a promise that'll resolve if the change succeeds. If anything goes
     * wrong, the promise will reject with a {@link TalkError}, which has a `code`
     * property to indicate what went wrong. Possible values in this case are:
     *
     * - `Talk.ErrorCode.NOTIFICATIONS_PERMISSION_DENIED`: The browser or the user
     *   didn't grant you permission to send notifications.
     *
     * - `Talk.ErrorCode.NOTIFICATIONS_NOT_SUPPORTED`: The browser doesn't support
     *   desktop notifications.
     */
    setDesktopNotificationEnabled(isEnabled: boolean, { alertOnFailure }?: {
        alertOnFailure?: boolean;
    }): Promise<void>;
    private _cleanUIBoxes;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.setPushRegistration}.
     *
     * Registers mobile device, one user can be connected to one mobile device.
     *
     * @remarks
     * Related method: {@link Session.unregisterDevice | Session.unregisterDevice}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    registerDevice({ platform, pushRegistrationId, }: {
        platform: "ios" | "android";
        pushRegistrationId: string;
    }): Promise<void>;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.unsetPushRegistration} or {@link Session.clearPushRegistrations}.
     *
     * Unregisters mobile device, one user can be connected to one mobile device.
     *
     * @remarks
     * Related method: {@link Session.registerDevice | Session.registerDevice}
     */
    unregisterDevice(): Promise<void>;
    /**
     * Registers a single mobile device, as one user can be connected to multiple mobile devices.
     *
     * @remarks
     * Related methods: {@link Session.unsetPushRegistration} {@link Session.clearPushRegistrations}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    setPushRegistration({ provider, pushRegistrationId, }: {
        provider: "fcm" | "apns";
        pushRegistrationId: string;
    }): Promise<void>;
    /**
     * Unregisters a single mobile device, as one user can be connected to multiple mobile devices.
     *
     * @remarks
     * Related methods: {@link Session.setPushRegistration} {@link Session.clearPushRegistrations}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    unsetPushRegistration({ provider, pushRegistrationId, }: {
        provider: "fcm" | "apns";
        pushRegistrationId: string;
    }): Promise<void>;
    /**
     * Unregisters all the mobile devices for the user.
     *
     * @remarks
     * Related methods: {@link Session.setPushRegistration} {@link Session.unsetPushRegistration}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    clearPushRegistrations(): Promise<void>;
    private _onNotificationClick;
    /**
     * Listens for an event
     *
     * @remarks
     * A `"message"` event is fired every time a message is sent or received by the
     * current user (even if no TalkJS UI is visible). Your `handler` function is passed
     * a {@link Message} object with some information about each message and its conversation.
     *
     * For an example, see {@link https://gist.github.com/eteeselink/607e585eb40be76f2ed150d4090e5261}
     *
     * Note that this event does not get triggered for conversations where the current user is a {@link https://talkjs.com/docs/Reference/Concepts/Guests/ | guest}.
     * It only applies to users who were added as participants.
     *
     * Related method: {@link Session.off}
     *
     * @deprecated Please use {@link Session.onMessage} instead.
     */
    on(eventType: "message", handler: (message: Message) => void): void;
    /**
     * Listens for an event
     *
     * @remarks
     * A `"desktopNotificationClicked"` event is fired every time a user clicks on a desktop notification
     * generated by TalkJS.
     *
     * When a user clicks on a notification, these things will happen:
     *
     * 1. The browser tab will be selected (note, this works in most browsers but cannot be guaranteed);
     *
     * 2. If you provided one or more "desktopNotificationClicked" handlers, they will be invoked in order;
     *
     * 3. If you did not, then the currently active inbox (if any) will jump to the conversation corresponding to the notification.
     *
     * See also {@link Session.setDesktopNotificationEnabled} and {@link Session.off}
     *
     * @deprecated Please use {@link Session.onDesktopNotificationClicked} instead.
     */
    on(eventType: "desktopNotificationClicked", handler: (event: DesktopNotificationClickedEvent) => void): void;
    /**
     * Used to stop listening to specific TalkJS session events.
     *
     * @remarks
     * Call this with the same `eventType` and `handler` to stop receiving events.
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Session.onMessage} instead.
     */
    off(eventType: "message", handler: (message: Message) => void): void;
    /**
     * Used to stop listening to specific TalkJS session events.
     *
     * @remarks
     * Call this with the same `eventType` and `handler` to stop receiving events.
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Session.onDesktopNotificationClicked} instead.
     */
    off(eventType: "desktopNotificationClicked", handler: (event: DesktopNotificationClickedEvent) => void): void;
    /**
     * Triggered when a message is sent in a conversation the current user is in.
     *
     * @remarks
     * A `"message"` event is fired every time a message is sent or received by the
     * current user (even if no TalkJS UI is visible). Your `handler` function is passed
     * a {@link Message} object with some information about each message and its conversation.
     *
     * Note that this event does not get triggered for conversations where the current user is a {@link https://talkjs.com/docs/Reference/Concepts/Guests/ | guest}.
     * It only applies to users who were added as participants.
     *
     */
    onMessage(handler: (message: Message) => void): Subscription;
    /**
     * Listen for when a user clicks a desktop notification.
     *
     * @remarks
     * A `"desktopNotificationClicked"` event is fired every time a user clicks on a desktop notification
     * generated by TalkJS.
     *
     * When a user clicks on a notification, these things will happen:
     *
     * 1. The browser tab will be selected (note, this works in most browsers but cannot be guaranteed);
     *
     * 2. If you provided one or more "desktopNotificationClicked" handlers, they will be invoked in order;
     *
     * 3. If you did not, then the currently active inbox (if any) will jump to the conversation corresponding to the notification.
     *
     * See also {@link Session.setDesktopNotificationEnabled}
     */
    onDesktopNotificationClicked(handler: (event: DesktopNotificationClickedEvent) => void): Subscription;
    /**
     * Triggered when a browser permission prompt is about to be shown.
     *
     * @remarks
     * Certain features, such as sharing location, sending voice messages, or
     * receiving notificatons, only work if the user has granted your app the
     * relevant permissions. By default, TalkJS will trigger the browser's
     * built-in permissions dialog the first time such a feature is used.
     *
     * This event is triggered *just before* this browser permissions dialog is
     * shown. This lets you show custom UI elements that let you show the user
     * where to look, or explain that it's all safe.
     *
     * If you return a promise from your event handler, then TalkJS will wait
     * until this promise resolves before showing the permission dialog.
     *
     * Note that it is not guaranteed that this event will trigger: It will only
     * trigger if we are certain that a permission prompt is about to show, and
     * unfortunately we can't be certain of that in all browsers. More explicitly,
     * it will only trigger when the browser supports the [Permissions
     * API](https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API) with
     * the given notification type.
     *
     * Notably:
     *
     * * Safari below 15.6 (2022) does not support the Permissions API at all
     *
     * * Firefox does not support querying the "microphone" permission, which
     *   TalkJS needs for voice messages.
     *
     * In these situations, this event will never trigger.
     *
     * @see {@link Session.onBrowserPermissionDenied} for a way to receive an event when the browser or the user denies the requested permission.
     */
    onBrowserPermissionNeeded(handler: (event: BrowserPermissionNeededEvent) => Promise<any> | void): Subscription;
    /**
     * Triggered when the user tried to do an action that requires explicit
     * browser permission, but this permission was denied.
     *
     * @remarks
     * This can be caused by user actions such as the sharing a location, enabling
     * desktop notifications, or trying to record a voice message. These features
     * require the user to explicitly grant the browser permission.
     *
     * This event can be triggered in two situations:
     *
     * 1. The browser showed the user a permission prompt, and the user picked
     *    "Deny". In this case, this event will have been preceded by
     *    {@link Session.onBrowserPermissionNeeded}.
     *
     * 2. The user has denied the same permission in the past and the browser
     *    remembered this decision. In this case, the action will fail immediately
     *    and an {@link Session.onBrowserPermissionNeeded} event will not have
     *    been emitted.
     *
     * In either case, the user may be able to allow the permission in their
     * browser settings. The intended use of this event is to show the user an
     * alert or dialog telling them how.
     *
     * Note: by default, TalkJS may display an error message in an `alert` if a
     * permission is denied. If you listen to this event, then these messages are
     * suppressed under the assumption that you will provide your own UI for this.
     */
    onBrowserPermissionDenied(handler: (event: BrowserPermissionNeededEvent) => void): Subscription;
    /**
     * Disconnects all websockets, removes all UIs, and invalidates this session.
     *
     * @remarks
     * You cannot use any objects that were created in this session after you destroy it.
     *
     * If you want to use TalkJS after having called `destroy()` you must instantiate a new
     * Talk.Session instance.
     */
    destroy(): void;
    /**
     * Returns a list of all active {@link Popup} objects linked to this
     * session.
     *
     * @remarks
     * Includes popups actively created using {@link Session.createPopup}, and also
     * popups created on page load, if {@link PopupOptions.keepOpen} was set to
     * `true` on an earlier page.
     *
     * Only includes popups that are still mounted in the DOM. So if you call
     * `createPopup()` but later remove its container element (or an ancestor of
     * the container), then the `Popup` object will have been made invalid and
     * is therefore not included in the results.
     */
    getPopups(): Popup[];
    /**
     * Returns a list of all active {@link Inbox} objects linked to this
     * session.
     *
     * @remarks
     * Only includes inboxes that are still mounted in the DOM. So if you call
     * `createInbox()` but later remove its container element (or an ancestor of
     * the container), then the `Inbox` object will have been made invalid and
     * is therefore not included in the results.
     */
    getInboxes(): Inbox[];
    /**
     * Returns a list of all active {@link Chatbox} objects linked to this
     * session.
     *
     * @remarks
     * Only includes chatboxes that are still mounted in the DOM. So if you call
     * `createChatbox()` but later remove its container element (or an ancestor of
     * the container), then the `Chatbox` object will have been made invalid and
     * is therefore not included in the results.
     */
    getChatboxes(): Chatbox[];
}

/**
 * @public
 */
export declare interface SessionOptions {
    /** Your app's unique TalkJS ID. Get it from the "Settings" page of your dashboard. */
    appId: string;
    /**
     * A `User` object that identifies the currently active user.
     * The user is uniquely identified by their id; all other fields
     * (name, photo, etc) are overwritten in the TalkJS database each
     * time they change, unless the user has been created with the alternate
     * constructor. */
    me: User;
    /**
     * A token to authenticate the session with.
     *
     * {@link https://talkjs.com/docs/Features/Security_Settings/Authentication/ | See the how-to guide} on generating authentication tokens, and many examples in different programming languages.
     *
     * {@link https://talkjs.com/docs/Features/Security_Settings/Advanced_Authentication/#token-reference | See the reference documentation} for full details on the technical requirements for the JWT.
     */
    token?: string;
    /**
     * A function that fetches and returns a new authentication token from your server.
     * TalkJS calls this function whenever the current token is about to expire.
     * This callback is designed to work with any backend setup.
     *
     * {@link https://talkjs.com/docs/Features/Security_Settings/Advanced_Authentication/#refreshable-tokens | See the how-to guide} on refreshable authentication tokens, and many examples in different programming languages.
     */
    tokenFetcher?: () => Promise<string>;
    /**
     * Legacy alternative to JWT authentication.
     * A HMAC-SHA256 hash of the current user ID, signed with your TalkJS secret key.
     *
     * {@link https://talkjs.com/docs/Features/Security_Settings/Advanced_Authentication/#signature-based-verification-legacy | See the documentation} for examples of how to generate a signature in different programming languages.
     *
     * @deprecated This will keep being supported, but for new projects, use {@link SessionOptions.token} instead.
     * JWT authentication is recommended because signatures never expire, meaning there is no way to revoke access.
     */
    signature?: string;
}

/**
 * Allows you to filter conversations down to a specific subset.
 *
 * @remarks
 * Use with {@link Inbox.setFeedFilter} or pass {@link InboxOptions.feedFilter} to
 * {@link Session.createInbox}. For example, to hide read conversations, use:
 *
 * `inbox.setFeedFilter({ hasUnreadMessages: true })`.
 *
 * To show everything (ie to disable the filter), use an empty object:
 *
 * `inbox.setFeedFilter({})`.
 *
 * @noinline
 * @public
 */
export declare interface SimpleConversationPredicate {
    /**
     * Only select conversations that the current user as specific access to.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * The operand must be either a string (one of `"ReadWrite"`, `"Read"` or `"None"`) or an array of strings (for the `oneOf` operators).
     *
     * Example:
     * ```js
     * // to remove conversations that the user has no access to anymore, do:
     * { access: ["!=", "None"] }
     * ```
     */
    access?: FieldPredicate<ConversationAccessLevel>;
    /**
     * Only select conversations that have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in the custom conversation data that you set (by passing
     * `custom` to {@link ConversationBuilder.setAttributes}). It is not necessary for all
     * conversations to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your conversations:
     *
     * ```js
     * // only show conversations that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // only show conversations of category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // only show conversations either category "shoes" or "sandals"
     * { custom: { category: ["oneOf", ["shoes", "sandals"] ] } }
     *
     * // only show conversations about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
    /**
     * Set this field to only select conversations that have, or don't have any, unread messages.
     */
    hasUnreadMessages?: boolean;
    /**
     * Only select conversations that have the subject set to particular values.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * The operand must be either a string or an array of strings (for the `oneOf` operators).
     *
     * Example:
     * ```js
     * // to show only the conversations that have "Black leather boots" or "Hair Wax 5 Gallons" as the subject
     * { subject: ["oneOf", ["Black leather boots", "Hair Wax 5 Gallons"]] }
     * ```
     */
    subject?: FieldPredicate<string | null>;
    /**
     * Only select conversations that have the last message sent in a particular time interval.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `">"`, `"<"`, `">="`, `"<="`, `"between"`, and `"!between"`.
     *
     * The operand must be either a number or a 2-element array of numbers (for the `between` operators).
     *
     * Example:
     * ```js
     * // to show only the conversations that have the last message sent after the UNIX timestamp 1679298371586
     * { lastMessageTs: [">", 1679298371586] }
     * ```
     */
    lastMessageTs?: NumberPredicate;
    /**
     * Only select conversations that have been created in a particular time interval.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `">"`, `"<"`, `">="`, `"<="`, `"between"`, and `"!between"`.
     *
     * The operand must be either a number or a 2-element array of numbers (for the `between` operators).
     *
     * Example:
     * ```js
     * // to show only the conversations that have been created after the UNIX timestamp 1679298371586
     * { createdAt: [">", 1679298371586] }
     * ```
     */
    createdAt?: NumberPredicate;
}

/**
 * Lets you show only specific messages in the chat panel of a Chatbox, Inbox or Popup.
 *
 * @remarks
 * Used in methods like {@link Chatbox.setMessageFilter}. For example, to hide all system messages (eg only show user messages), do:
 *
 * `chatbox.setMessageFilter({type: ["==", "UserMessage"]})`
 *
 * To show all messages (ie disable the filter), just pass an empty object:
 *
 * `chatbox.setMessageFilter({})`
 *
 * @noinline
 * @public
 */
export declare interface SimpleMessagePredicate {
    /**
     * Only show messages that are sent by a sender that has all of the given properties
     *
     * For example:
     *
     * ```js
     * // Only show messages sent by users with the role of 'admin' and if the user ID is 1.
     * {sender: {role: ["==", "admin"], id: ["==", "1"]}}
     * ```
     */
    sender?: SenderPredicate;
    /**
     * Only show messages of a given type, for example:
     *
     * ```js
     * {type: ["==", "SystemMessage"]}
     * ```
     *
     */
    type?: FieldPredicate<"UserMessage" | "SystemMessage">;
    /**
     * Only show messages that were sent by users (web), through the REST API (rest), via
     * reply-to-email (email) or via the import REST API (import).
     *
     * For example:
     *
     * ```js
     * // Don't show messages that were sent via the REST API
     * { origin: ["!=", "rest"] }
     * ```
     *
     */
    origin?: FieldPredicate<"web" | "rest" | "email" | "import">;
    /**
     * Only select messages that have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in the custom message data that you have set. It is not necessary for all
     * messages to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your messages:
     *
     * ```js
     * // Only show messages that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // Only show messages of that have the category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // Only show messages that have the 'topic' either "inquiry" or "reservation"
     * { custom: { topic: ["oneOf", ["inquiry", "reservation"] ] } }
     *
     * // Only show messages about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
    /**
     * Only select messags that have been sent in a particular time interval.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `">"`, `"<"`, `">="`, `"<="`, `"between"`, and `"!between"`.
     *
     * The operand must be either a number or a 2-element array of numbers (for the `between` operators).
     *
     * Example:
     * ```js
     * // to show only the messages that have been sent after the UNIX timestamp 1679298371586
     * { createdAt: [">", 1679298371586] }
     * ```
     */
    createdAt?: NumberPredicate;
}

/**
 * A subscription to an event
 * @public
 */
export declare interface Subscription {
    /**
     * Stop receiving events for this subscription
     */
    unsubscribe(): void;
}

/**
 * TalkJS Error class, inherits from the global Error class.
 *
 * @remarks
 * TalkJS methods may throw (or reject promises with) instances of this class
 * if specific catchable information can be provided through the `code` property.
 *
 * @public
 */
export declare class TalkError extends Error {
    /**
     * Machine-readable error code
     */
    code: ErrorCode;
    /**
     * Human-readable error message
     */
    message: string;
}

/**
 * @public
 */
export declare interface ThemeOptions {
    /**
     * The name of the theme to use in this widget
     * If no theme name is given, TalkJS will use the theme set in the user's role,
     * falling back to the default theme if the user has no role.
     */
    name?: string;
    /**
     * A map of values that will be available to your theme under the `theme.custom` namespace.
     * The values can be anything that can be JSON-serialized.
     * String and numeric values will also be made available as CSS custom properties in themes, available as `var(--theme-<key>)`. where `<key>` is the value's key in the object.
     */
    custom?: {
        [key: string]: JsonSerializable;
    };
}

/**
 * @public
 * Used to configure supported third-party integrations with TalkJS. See
 * {@link https://talkjs.com/docs/Features/Customizations/Third_Party_Integrations.html | third party integrations }
 *
 */
export declare interface ThirdPartyOptions {
    fullstory?: FullStoryOptions;
}

/**
 * @public
 * This event is triggered when the user toggles real-time message translation using the built-in toggle.
 */
export declare interface TranslationToggledEvent {
    /**
     * Boolean indicating if translation is enabled or not
     */
    isEnabled: boolean;
    /**
     * Conversation for which translation has been toggled
     */
    conversation: ConversationData;
}

/**
 * @public
 * @hidden
 */
export declare interface UIBox {
    /**
     * The conversation currently shown in the UI.
     *
     * @remarks
     * This field is `null` when the UI does not currently show a conversation (eg
     * because `null` was passed to {@link UIBox.select} or the selected
     * conversation could not be found).
     */
    readonly currentConversation: ConversationData | null;
    /**
     * Whether the object is active and in a valid state.
     *
     * @remarks
     * When false, calling methods on this instance will throw errors.
     *
     * This field is false when {@link UIBox.destroy} has been called in the past.
     * It is also false if {@link Session.destroy} has been called, because
     * destroying a session destroys all its UI widgets.
     *
     * Finally, an instance may also be considered if its previously mounted
     * iframe has been removed from the DOM by some external library.
     *
     * Once this instance has been destroyed, you cannot revive it. Instead,
     * create a new instance.
     */
    readonly isAlive: boolean;
    /**
     * Switches the active conversation. Returns a promise that resolves once the new conversation has been selected.
     *
     * @remarks
     * `conversation` can be either a {@link ConversationBuilder} object or a TalkJS
     * conversation id. Passing `null` means that the conversation will be de-selected in the UI and the message list will disappear.
     * Passing `undefined` means that the last conversation (or "no chats yet" page if there are no other conversations) will be rendered in the message list component.
     */
    select(conversation: string | Conversation | ConversationBuilder | null | undefined, params?: SelectConversationOptions): Promise<void>;
    /**
     * Encapsulates the message entry field tied to the currently selected conversation.
     */
    messageField: MessageField;
    /**
     * Upload a file attachment to the currently active conversation.
     *
     * @remarks
     * The behaviour of this method is similar to if the user clicked the attachment button, in that the confirmation
     * dialog is shown to the user.
     *
     * Ensure that the {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File} object's name property has
     * an appropriate file extension.
     *
     * @param file - The {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File} object to be uploaded.
     */
    sendFile(file: File): Promise<void>;
    /**
     * Send the user's current location to the currently active conversation.
     *
     * @remarks
     * The behaviour of this method is identical to the user clicking the location button in message field i.e the confirmation
     * dialog is shown.
     *
     * Note: If the user had not previously granted location access to your website, calling this method will
     * trigger the browser's popup asking them for permission to access their location. The user's location will only be
     * shared if they allow.
     */
    sendLocation(): Promise<void>;
    /**
     * Listens for an event.
     *
     * @remarks
     * Triggers when the user sends a message using the TalkJS UI
     *
     * @deprecated Please use {@link Chatbox.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere inside the chat UI.
     *
     * @deprecated Please use {@link Chatbox.onFocus} instead.
     */
    on(eventType: "focus", handler: () => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere outside the chat UI.
     *
     * @deprecated Please use {@link Chatbox.onBlur} instead.
     */
    on(eventType: "blur", handler: () => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Triggers when the user toggles translation in a conversation
     * @deprecated Please use {@link Chatbox.onTranslationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * This event is only emitted when {@link ChatboxOptions.captureKeyboardEvents} is enabled. In
     * that case, it is emitted for every keypress, including regular letters typed into text fields.
     *
     * `event.isInputFocused` is true when a TalkJS input area is focused (eg the message field, the
     * search box, or adjacent buttons). When this is the case, keypresses are likely to cause changes
     * inside the chat UI. We recommend that you discard these events except when implementing global
     * shortcuts that should take effect regardless of whether the user is typing a message or
     * otherwise interacting with the chat UI using the keyboard.
     *
     * Note: by design, TalkJS does not handle special multi-key shortcuts other than those provided
     * by the user's device (eg ctrl+v for paste). This means that it is usually safe to assign
     * special behavior to unused keyboard shortcuts with one or more modifier keys (like alt, shift
     * or ctrl), even when `isInputFocused` is true.
     *
     * All other event fields are the same as the corresponding fields in the browser's
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
     *
     * @example
     * ```ts
     * myChatbox.on("keyup", event => {
     *   if(event.shiftKey || event.altKey || event.metaKey) {
     *     return;
     *   }
     *   if(!event.isInputFocused && event.key === "1") {
     *     // let the 1 key switch to our app's main panel, except if the user is typing
     *     myApp.selectMainPanel();
     *   }
     *   if(event.ctrlKey && event.key === "q") {
     *     // quit if the user hits ctrl+q, irrespective of whether they're typing.
     *     myApp.quit();
     *   }
     * });
     * ```
     *
     * @deprecated Please use {@link Chatbox.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * @hidden
     */
    onCustomMessageAction(handler: (event: MessageActionEvent) => void): Subscription;
    /**
     * Triggers when a user launches a custom action on a message within the TalkJS UI.
     *
     * @remarks
     * To set up a custom action, you can either create it on the "Chat UI" page in your dashboard,
     * add an action button to your messages,
     * or add an action button to the `UserMessage`, `SystemMessage`,
     * or `MessageBody` components of your theme in the Theme Editor,
     * which you can access from the "Themes" page in your dashboard.
     * If an action is allowed on a particular message, it'll show up in that message's action menu.
     * The name you specify when setting up the action, is also the name you should pass in here (case sensitive).
     * The event you get contains information about the message on which the action was called, including its ID, so you can look it up later via our REST API.
     * @param action - Optional. The action you want to listen for. Omit to listen for any action.
     * @param handler - The handler to be called
     * @returns A subscription you can use to unsubscribe.
     */
    onCustomMessageAction(action: string, handler: (event: MessageActionEvent) => void): Subscription;
    /**
     * @hidden
     */
    onCustomConversationAction(handler: (event: ConversationActionEvent) => void): Subscription;
    /**
     * Triggers when a user launches a custom action on a conversation within the
     * TalkJS UI.
     *
     * @remarks
     * To set up a custom action, you can either create it on the "Chat UI" page in
     * your dashboard or add an action button to the `ChatHeader`, `MessageField`,
     * `ConversationListHeader` or `ConversationListItem` components of your theme
     * in the Theme Editor, which you can access from the "Themes" page in your dashboard.
     * If an action is allowed on a particular conversation, it'll show up in that
     * conversation's action menu. The name you specify when setting up the
     * action, is also the name you should pass in here (case sensitive). The
     * event you get contains information about the conversation on which the
     * action was called, including its ID, so you can look it up later via our
     * REST API.
     * @param action - Optional. The action you want to listen for. Omit to listen for any action.
     * @param handler - The handler to be called
     * @returns A subscription you can use to unsubscribe.
     */
    onCustomConversationAction(action: string, handler: (event: ConversationActionEvent) => void): Subscription;
    /**
     * Triggers when the user sends a message using the TalkJS UI
     */
    onSendMessage(handler: (event: SendMessageEvent) => void): Subscription;
    /**
     * Triggers when the user clicks on the "Leave conversation" action
     *
     * @remarks
     * This event triggers *before* the user actually leaves the conversation. You
     * can call `event.preventDefault()` to disallow the user from actually
     * leaving.
     *
     * This event only triggers when the user performs a Leave action from inside
     * the chat UI. Notably, when a user leaves the conversation through other
     * means (for example, they're removed from the conversation using the REST
     * API), this event does not trigger.
     */
    onLeaveConversation(handler: (event: LeaveConversationEvent) => void): Subscription;
    /**
     * Triggers when the user clicks on the "Mark as unread" action
     *
     * @remarks
     * This event triggers *before* the user actually marks the conversation as
     * unread. You can call `event.preventDefault()` to disallow the user from
     * actually marking it as unread.
     *
     * This event only triggers when the user performs a "Mark as unread" action
     * from inside the chat UI. Notably, when a user marks the conversation as
     * unread through other means (for example, via the REST API), this event does
     * not trigger.
     */
    onMarkConversationAsUnread(handler: (event: MarkConversationAsUnreadEvent) => void): Subscription;
    /**
     * Triggers when the chat UI is focussed.
     */
    onFocus(handler: () => void): Subscription;
    /**
     * Triggers when focus moves out of the chat UI.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere outside the chat UI.
     */
    onBlur(handler: () => void): Subscription;
    /**
     * Triggers when the user toggles message translation in the TalkJS UI.
     */
    onTranslationToggled(handler: (event: TranslationToggledEvent) => void): Subscription;
    /**
     * Triggers a {@link KeyEvent} when the user releases a key.
     *
     * @remarks
     * This event is only emitted when
     * {@link ChatboxOptions.captureKeyboardEvents} is enabled. In that case, it
     * is emitted for every keypress, including regular letters typed into text
     * fields.
     *
     * Note that there's a notorious system limitation on macOS: `metaKey` is not
     * set in keyup events when hitting keystrokes (eg Cmd+p). Consider using
     * {@link UIBox.onKeydown} if you need to support `Cmd`.
     *
     * `event.isInputFocused` is true when a TalkJS input area is focused (eg the
     * message field, the search box, or adjacent buttons). When this is the case,
     * keypresses are likely to cause changes inside the chat UI. We recommend
     * that you discard these events except when implementing global shortcuts
     * that should take effect regardless of whether the user is typing a message
     * or otherwise interacting with the chat UI using the keyboard.
     *
     * Note: by design, the TalkJS UI does not handle special multi-key shortcuts
     * other than those provided by the user's device (eg ctrl+v for paste). This
     * means that it is usually safe to assign special behavior to unused keyboard
     * shortcuts with one or more modifier keys (like alt, shift or ctrl), even
     * when `isInputFocused` is true.
     *
     * All other event fields are the same as the corresponding fields in the
     * browser's
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
     *
     * @example
     * ```ts
     * myChatbox.onKeyup(event => {
     *   if(event.shiftKey || event.altKey || event.metaKey) {
     *     return;
     *   }
     *
     *   // let the 1 key switch to our app's main panel, except if the user is typing
     *   if(!event.isInputFocused && event.key === "1") {
     *     myApp.selectMainPanel();
     *   }
     *
     *   // quit if the user hits ctrl+q, irrespective of whether they're typing.
     *   if(event.ctrlKey && event.key === "q") {
     *     myApp.quit();
     *   }
     * });
     * ```
     */
    onKeyup(handler: (event: KeyEvent) => void): Subscription;
    /**
     * Triggers a {@link KeyEvent} when the user presses a key.
     *
     * @remarks
     * See {@link UIBox.onKeyup} for more details.
     */
    onKeydown(handler: (event: KeyEvent) => void): Subscription;
    /**
     * Puts custom HTML just above the message field.
     *
     * @remarks
     * Using HTML Panels, you can extend TalkJS UIs to have anything from credit card payments to lead
     * collection forms, or, for instance, to show the product details of a marketplace transaction
     * between your users. See our
     * {@link https://talkjs.com/docs/Features/Customizations/HTML_Panels.html | HTMLPanels documentation}
     * for more info.
     */
    createHtmlPanel(options: HtmlPanelOptions): Promise<HtmlPanel>;
    /**
     * Sets metadata for the current session.
     *
     * @remarks
     * <b>Note:</b> If you want to mount UI that is already hidden, set
     *  {@link ChatboxOptions.presence | presence when creating the UI} or call
     * `setPresence({ visible: false })` before calling {@link UIBox.mount}.
     *
     * Also, important to note, is that the {@link Popup} internally calls this method
     * when a user opens or closes it. `visible` is set to `true` or `false` respectively.
     *
     */
    setPresence(presence: UserPresence): void;
    /**
     * Destroys the component and removes it from the DOM
     *
     * @remarks
     * Destroys the component, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the the component container from the DOM.
     */
    destroy(): void;
    /**
     * Toggles desktop notifications
     *
     * @remarks
     * This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.setDesktopNotificationEnabled}.
     *
     * Sets desktop notification on or off. Has the same effect as toggling the
     * "Desktop notification" toggle in the TalkJS Inbox UI. Use this function to replicate that
     * toggle elsewhere in your UI if you're using TalkJS in a mode that doesn't show this toggle.
     *
     * @deprecated Please use {@link Session.setDesktopNotificationEnabled} instead.
     */
    toggleDesktopNotifications(isEnabled: boolean): void;
    /**
     * Used to control which messages are shown in the message list
     *
     * @remarks
     * Lets you filter messages depending on a type, origin or custom message attributes.
     *
     * <b>Note</b>: Messages are only filtered in the message list. The inbox UI's conversation feed will
     * always show the last message sent to the conversation, regardless of the message filter set.
     *
     * See {@link MessagePredicate} for all available options.
     *
     * @example
     * ```ts
     * // only show messages sent by users with role "admin"
     * chatbox.setMessageFilter({
     *   sender: {
     *     role: ["==", "admin"],
     *   }
     * });
     * ```
     *
     * @param filter - A predicate object that controls which messages are shown.
     */
    setMessageFilter(filter: MessagePredicate): void;
    /**
     * Enable or disable translation for a conversation.
     *
     * @param conversation - The conversation for which this should be set. If not specified, the setting will be applied to the currently selected conversation.
     * @param enabled - Whether translation should be enabled
     */
    setTranslationEnabledForConversation(conversation: string | ConversationBuilder, enabled: boolean): void;
    /**
     * Enable/disable translation by default.
     *
     * @remarks
     * This setting is applied to any conversation for which you haven't set a specific value.
     *
     * @param enabled - Whether conversations should be translated by default or not. Pass "auto" to
     *                  enable translation for conversations with users with different locales.
     */
    setTranslationEnabledDefault(enabled: boolean | "auto"): void;
    /**
     * Highlights certain words in messages
     *
     * @remarks
     * The TalkJS search feature includes the ability to highlight certain words in messages. Call
     * this method to highlight certain words without having the user invoke the search feature.
     * Call again with an empty array to disable highlighting.
     *
     * Note: like the search feature, this option only works on the Growth plan and up.
     *
     * Also see {@link ChatboxOptions.highlightedWords}
     */
    setHighlightedWords(words: string[]): void;
}

/**
 * @public
 * Used as part of {@link Unreads.on}.
 */
export declare interface UnreadConversation {
    /**
     * The {@link ConversationData} of the unread conversation.
     *
     * @remarks
     * Always identical to `lastMessage.conversation`, which is maintained for
     * compatibility reasons.
     */
    conversation: ConversationData;
    /**
     * Contains the last {@link Message} for this conversation.
     */
    lastMessage: Message;
    /**
     *
     * The number of unread messages in this conversation.
     *
     * Note: Conversations with last activity before 15 June 2023 will have `unreadMessageCount` value set to 0 on initial load. It will be properly set after the next refresh
     */
    unreadMessageCount: number;
}

/**
 * This object can notify you when the amount of unread conversations changes.
 * You can't instantiate it - instead, get an instance via {@link Session.unreads}.
 *
 * @public
 */
export declare interface Unreads {
    /**
     * A "change" event is fired on startup right after TalkJS loads, as well as every time the
     * amount of unread conversations changed. The `handler` is invoked with an array of objects with
     * limited information about each conversation, see {@link UnreadConversation}.
     *
     * @remarks
     * Note that conversations where the user is a {@link https://talkjs.com/docs/Reference/Concepts/Guests/ | guest}
     * do not keep track of unread messages. This is only done for users who are added as participants.
     *
     * Related methods: {@link Unreads.off}
     *
     * @deprecated Please use {@link Unreads.onChange} instead.
     */
    on(eventType: "change", handler: (unreadConversations: UnreadConversation[]) => void): void;
    /**
     * Call this with the same `eventType` and `handler` that you used for `on` to
     * stop receiving events.
     *
     * @remarks
     * Related methods: {@link Unreads.on}
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Unreads.onChange} instead.
     */
    off(eventType: "change", handler: (unreadConversations: UnreadConversation[]) => void): void;
    /**
     * Triggered when the list of unread conversations changes.
     *
     * @remarks
     * A "change" event is fired on startup right after TalkJS loads, as well as every time the
     * amount of unread conversations changed. The `handler` is invoked with an array of objects with
     * limited information about each conversation, see {@link UnreadConversation}.
     *
     * Note that conversations where the user is a {@link https://talkjs.com/docs/Reference/Concepts/Guests/ | guest}
     * do not keep track of unread messages. This is only done for users who are added as participants.
     */
    onChange(handler: (unreadConversations: UnreadConversation[]) => void): Subscription;
}

/**
 * A user of your app. TalkJS uses the `id` to uniquely identify this user.
 * All other fields of a User are allowed to vary over time and the TalkJS database will update its fields accordingly.
 * @public
 */
export declare class User {
    /**
     * The unique ID which is used to identify the user in TalkJS
     */
    readonly id: string;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    readonly name: string;
    /**
     * One or more email address belonging to the User. The email addresses will be used for {@link https://talkjs.com/docs/Features/Notifications/Email_Notifications/index.html | Email Notifications}
     * if they are enabled.
     */
    readonly email?: string | Array<string> | null;
    /**
     * One or more phone numbers belonging to the User. The phone number will be used for {@link https://talkjs.com/docs/Features/Notifications/SMS_Notifications.html | SMS Notifications }
     * (this feature requires standard plan and up).
     */
    readonly phone?: string | Array<string> | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    readonly welcomeMessage?: string | null;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    readonly photoUrl?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    readonly role?: string | null;
    /**
     * @deprecated Please use {@link User.role} instead.
     */
    readonly configuration?: string | null;
    /**
     * Allows you to set custom metadata for the User
     */
    readonly custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     *
     */
    readonly availabilityText?: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}.
     */
    readonly locale?: string | null;
    /**
     * Create a TalkJS User
     *
     * @remarks
     * Use this constructor to create or update user data.
     * The user is {@link https://talkjs.com/docs/Features/Security_Settings/Browser_Synchronization.html | synchronized}
     * with the TalkJS backend if they are the current user in a session.
     * If they are not the current user, and they are part of an existing conversation,
     * they will be synchronized when the UI is mounted.
     *
     * The fields `id`, `name` and `email` are required.
     * A warning will be emitted if `role` is not specified.
     *
     * Set `email` to `null` if you want to use TalkJS without email fallback.
     */
    constructor(options: UserOptions);
    /**
     * Create a TalkJS User
     *
     * @remarks
     * Only use this constructor if you're sure
     * that a user by the given `id` already exists in TalkJS (for instance, because you
     * synchronized it via the REST API). Otherwise use the `new User(options: object):` constructor instead.
     */
    constructor(id: string | number);
}

/**
 * @public
 */
export declare interface UserData {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
     */
    id: string | number;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    photoUrl: string | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    welcomeMessage: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    role: string | null;
    /**
     * @deprecated Please use {@link UserData.role} instead.
     */
    configuration: string | null;
    /**
     * Allows you to set custom metadata for the User
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom: CustomData;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     */
    availabilityText: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}.
     */
    locale: string | null;
}

/**
 * @public
 */
export declare interface UserOptions {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
     */
    id: string | number;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * One or more email address belonging to the User. The email addresses will be used for {@link https://talkjs.com/docs/Features/Notifications/Email_Notifications/index.html | Email Notifications}
     * if they are enabled.
     * @remarks
     * Set to `null` to delete the existing value(s) (if any). When omitted or `undefined`, the existing value(s) remain unchanged.
     */
    email?: string | Array<string> | null;
    /**
     * One or more phone numbers belonging to the User. The phone number will be used for {@link https://talkjs.com/docs/Features/Notifications/SMS_Notifications.html | SMS Notifications }
     * (this feature requires standard plan and up).
     * @remarks
     * Set to `null` to delete the existing value(s) (if any). When omitted or `undefined`, the existing value(s) remain unchanged.
     */
    phone?: string | Array<string> | null;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    photoUrl?: string | null;
    /**
     * The default message a user sees when starting a chat with that person
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    welcomeMessage?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    role?: string | null;
    /**
     * @deprecated Please use {@link UserOptions.role} instead.
     */
    configuration?: string | null;
    /**
     * Allows you to set custom metadata for the User
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * @deprecated Please use {@link Conversation.welcomeMessages} instead.
     *
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     *
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    availabilityText?: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}.
     *
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    locale?: string | null;
}

/**
 * Parameters you can pass when creating or updating a user.
 *
 * @public
 */
export declare interface UserParams {
    /**
     * The user's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * Custom metadata you have set on the user
     */
    custom: Record<string, string>;
    /**
     * An {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}
     */
    locale: string;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    photoUrl: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    role: string;
    /**
     * The default message a person sees when starting a chat with this user
     */
    welcomeMessage: string | null;
    /**
     * An array of email addresses associated with the user.
     */
    email: string[] | null;
    /**
     * An array of phone numbers associated with the user.
     */
    phone: string[] | null;
    /**
     * An object of push registration tokens to use when notifying this user.
     *
     * Keys in the object have the format `'provider:token_id'`,
     * where `provider` is either `"fcm"` for Android (Firebase Cloud Messaging),
     * or `"apns"` for iOS (Apple Push Notification Service).
     *
     * The value for each key can be either true for registering the device for push notifications, or null for unregistering the device.
     *
     * Setting pushTokens to null unregisters all the previously registered devices.
     */
    pushTokens: Record<string, true | null> | null;
}

/**
 * @public
 */
export declare interface UserPresence {
    /**
     * Manually sets the information about the visibility of TalkJS.
     * This is useful when TalkJS is hidden with CSS. TalkJS will assume that UIs
     * marked `visible: false` cannot be seen, and thus messages arriving on this UI will
     * not be marked as read until you set `visible` to true again.
     * @remarks
     * When omitted or `undefined`, the existing value remains unchanged.
     */
    visible?: boolean;
    /**
     * This is an additional parameter to store the custom fields that you
     * may want to use in the REST API call.
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: CustomData;
}

/**
 * References the user with a given ID.
 *
 * @remarks
 * Used in all Realtime API operations affecting that user, eg fetching/updating their data or adding them to a conversation.
 * Created via {@link Session.user}.
 *
 * @public
 */
export declare interface UserRef {
    /**
     * The ID of the referenced user.
     *
     * @remarks
     * Immutable: if you want to reference a different user, get a new UserRef instead.
     */
    readonly id: string;
    /**
     * Fetch a snapshot of the user.
     *
     * @remarks
     * This contains all of a user's public information.
     * This does not require any permissions, you can read the public information of any user.
     * Private information such as email addresses and phone numbers are not included in the response.
     *
     * @returns A snapshot of the user's public attributes, or null if the user does not exist.
     */
    get(): Promise<UserSnapshot | null>;
    /**
     * Sets properties of this user, the user will be created if it doesn't exist.
     *
     * @remarks
     * This operation will fail if client-side user syncing is disabled.
     *
     * @returns A promise that resolves when the operation completes.
     */
    set(params: Partial<UserParams>): Promise<void>;
    /**
     * Creates a user if it doesn't already exist.
     *
     * @remarks
     * This operation will fail if client-side user syncing is disabled.
     *
     * @returns A promise that resolves when the operation completes.
     */
    createIfNotExists(params: Partial<UserParams>): Promise<void>;
}

/**
 * A snapshot of a user's attributes at a given moment in time.
 *
 * @remarks
 * Users also have email addresses and phone numbers, but these are only exposed on the REST API.
 *
 * @public
 */
export declare interface UserSnapshot {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
     */
    id: string;
    /**
     * The user's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * Custom metadata you have set on the user
     */
    custom: Record<string, string>;
    /**
     * An {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}
     */
    locale: string;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    photoUrl: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    role: string;
    /**
     * The default message a person sees when starting a chat with this user
     */
    welcomeMessage: string | null;
}

export { }
